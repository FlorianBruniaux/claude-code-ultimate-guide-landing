/**
 * remark-guide-links.mjs
 *
 * Remark plugin that rewrites relative links in guide content for Starlight:
 *
 *   Pattern                           → Transformation
 *   ─────────────────────────────────────────────────────────────────────
 *   ./data-privacy.md                 → /guide/data-privacy/
 *   ./workflows/tdd-with-claude.md    → /guide/workflows/tdd-with-claude/
 *   ./ultimate-guide.md#4-agents      → /guide/ultimate-guide/04-agents/#4-agents (via anchor map)
 *   ./architecture.md#section         → /guide/architecture/#section
 *   ./images/foo.jpeg                 → /guide/images/foo.jpeg
 *   ../examples/agents/foo.md         → https://github.com/.../examples/agents/foo.md (fallback)
 *   ../CONTRIBUTING.md                → https://github.com/.../CONTRIBUTING.md (fallback)
 *   #section-anchor                   → unchanged (same-page anchor)
 *   https://...                       → unchanged (external URL)
 */

import { readFileSync, existsSync } from 'fs'
import { resolve, dirname } from 'path'
import { fileURLToPath } from 'url'
import { visit } from 'unist-util-visit'

const __dirname = dirname(fileURLToPath(import.meta.url))
const ROOT = resolve(__dirname, '..')

const GITHUB_BASE = 'https://github.com/FlorianBruniaux/claude-code-ultimate-guide/blob/main/'
const GUIDE_BASE = '/guide/'

// Image extensions to handle as static files
const IMAGE_EXTS = new Set(['.jpeg', '.jpg', '.png', '.gif', '.svg', '.webp', '.avif'])

// Load anchor map (generated by prepare-guide-content.mjs)
function loadAnchorMap() {
  const anchorMapPath = resolve(ROOT, 'src/data/guide-anchor-map.json')
  try {
    const raw = readFileSync(anchorMapPath, 'utf-8')
    return JSON.parse(raw)
  } catch {
    return {}
  }
}

/**
 * Convert a guide-relative file path to a Starlight URL.
 * Returns null if the path should fall back to GitHub.
 *
 * @param {string} href - The raw href value (e.g., "./architecture.md")
 * @param {string|undefined} anchorFragment - URL fragment (e.g., "#section") or undefined
 * @param {object} anchorMap - Map of anchor → chapter slug
 * @returns {{ url: string, isExternal: boolean } | null}
 */
function resolveGuideLink(href, anchorFragment, anchorMap) {
  // Normalize: strip leading ./
  const cleanHref = href.replace(/^\.\//, '')

  // ── Images ────────────────────────────────────────────────────────────
  const imageExt = IMAGE_EXTS.has('.' + cleanHref.split('.').pop()?.toLowerCase() || '')
  if (cleanHref.startsWith('images/') || IMAGE_EXTS.has('.' + (cleanHref.split('.').pop() || ''))) {
    return { url: '/guide/' + cleanHref, isExternal: false }
  }

  // ── ultimate-guide.md (split into chapters) ────────────────────────
  if (cleanHref === 'ultimate-guide.md' || cleanHref.startsWith('ultimate-guide.md#')) {
    const anchor = anchorFragment?.replace('#', '') || ''
    if (anchor && anchorMap[anchor]) {
      return { url: `${GUIDE_BASE}${anchorMap[anchor]}/#${anchor}`, isExternal: false }
    }
    // No specific anchor or not found in map → link to ultimate guide index
    return { url: `${GUIDE_BASE}ultimate-guide/`, isExternal: false }
  }

  // ── Relative guide files (same directory) ─────────────────────────
  if (cleanHref.endsWith('.md') && !cleanHref.includes('/')) {
    const slug = cleanHref.replace(/\.md$/, '')
    const fragment = anchorFragment || ''
    return { url: `${GUIDE_BASE}${slug}/${fragment}`, isExternal: false }
  }

  // ── Workflow files ─────────────────────────────────────────────────
  if (cleanHref.startsWith('workflows/') && cleanHref.endsWith('.md')) {
    const slug = cleanHref.replace(/\.md$/, '')
    const fragment = anchorFragment || ''
    return { url: `${GUIDE_BASE}${slug}/${fragment}`, isExternal: false }
  }

  // ── Anything starting with ../ → fall back to GitHub ──────────────
  if (href.startsWith('../') || href.startsWith('..\\')) {
    return null // signal: use GitHub fallback
  }

  // ── Absolute paths or other formats → unchanged ───────────────────
  return null
}

/**
 * Convert a guide-relative path to its GitHub URL (fallback for out-of-guide links).
 */
function toGitHubUrl(href) {
  // Strip leading ../
  const withoutDotDot = href.replace(/^(\.\.\/)+/, '')
  return GITHUB_BASE + withoutDotDot
}

/**
 * The remark plugin factory
 */
export function remarkGuideLinks() {
  const anchorMap = loadAnchorMap()

  return function transformer(tree, file) {
    // Only process files inside the guide content dir
    const filePath = file?.history?.[0] || ''
    if (!filePath.includes('content/docs/guide')) return

    visit(tree, ['link', 'image'], (node) => {
      const originalUrl = node.url || ''

      // Skip: external URLs
      if (originalUrl.startsWith('http://') || originalUrl.startsWith('https://')) return
      // Skip: same-page anchors
      if (originalUrl.startsWith('#')) return
      // Skip: data: URIs
      if (originalUrl.startsWith('data:')) return
      // Skip: absolute paths
      if (originalUrl.startsWith('/')) return

      // Split URL from fragment
      const hashIdx = originalUrl.indexOf('#')
      const hrefPart = hashIdx >= 0 ? originalUrl.slice(0, hashIdx) : originalUrl
      const fragmentPart = hashIdx >= 0 ? originalUrl.slice(hashIdx) : ''

      if (!hrefPart) return // pure anchor, skip

      const resolved = resolveGuideLink(hrefPart, fragmentPart, anchorMap)

      if (resolved) {
        node.url = resolved.url
      } else if (hrefPart.startsWith('../') || hrefPart.startsWith('..\\')) {
        // Fall back to GitHub for out-of-guide references
        node.url = toGitHubUrl(hrefPart) + fragmentPart
      }
      // Otherwise: leave unchanged (unknown relative path)
    })
  }
}

export default remarkGuideLinks
